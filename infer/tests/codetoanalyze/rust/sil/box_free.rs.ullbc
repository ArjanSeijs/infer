{"charon_version":"0.1.123","translated":{"crate_name":"box_free","options":{"ullbc":true,"lib":false,"bin":null,"mir_promoted":false,"mir_optimized":false,"mir":null,"input_file":null,"read_llbc":null,"dest_dir":null,"dest_file":"box_free.rs.ullbc","use_polonius":false,"skip_borrowck":false,"monomorphize":false,"monomorphize_conservative":false,"extract_opaque_bodies":false,"translate_all_methods":false,"include":[],"opaque":[],"exclude":[],"remove_associated_types":[],"hide_marker_traits":true,"hide_allocator":true,"remove_unused_self_clauses":false,"add_drop_bounds":false,"start_from":[],"no_cargo":false,"rustc_args":[],"cargo_args":[],"abort_on_error":false,"error_on_warnings":false,"no_serialize":false,"print_original_ullbc":false,"print_ullbc":true,"print_built_llbc":false,"print_llbc":false,"no_merge_goto_chains":false,"no_ops_to_function_calls":false,"raw_boxes":false,"preset":null},"target_information":{"target_pointer_size":8,"is_little_endian":true},"item_names":[{"key":{"Global":0},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["{vtable}",0]}]},{"key":{"TraitDecl":1},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Sized",0]}]},{"key":{"Fun":2},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["allocate",0]}]},{"key":{"TraitImpl":0},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}}]},{"key":{"Global":1},"value":[{"Ident":["alloc",0]},{"Ident":["boxed",0]},{"Impl":{"Trait":1}},{"Ident":["{vtable}",0]}]},{"key":{"Fun":6},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["grow_zeroed",0]}]},{"key":{"Type":2},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["MetaSized",0]},{"Ident":["{vtable}",0]}]},{"key":{"TraitDecl":3},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["drop",0]},{"Ident":["Drop",0]}]},{"key":{"TraitDecl":0},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["MetaSized",0]}]},{"key":{"Fun":3},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["allocate_zeroed",0]}]},{"key":{"TraitDecl":2},"value":[{"Ident":["core",0]},{"Ident":["alloc",0]},{"Ident":["Allocator",0]}]},{"key":{"TraitImpl":1},"value":[{"Ident":["alloc",0]},{"Ident":["boxed",0]},{"Impl":{"Trait":1}}]},{"key":{"Fun":8},"value":[{"Ident":["alloc",0]},{"Ident":["boxed",0]},{"Impl":{"Trait":1}},{"Ident":["drop",0]}]},{"key":{"Type":1},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["drop",0]},{"Ident":["Drop",0]},{"Ident":["{vtable}",0]}]},{"key":{"Fun":5},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["grow",0]}]},{"key":{"Fun":7},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["shrink",0]}]},{"key":{"Fun":1},"value":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["drop",0]},{"Ident":["Drop",0]},{"Ident":["drop",0]}]},{"key":{"Type":0},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Ident":["Global",0]}]},{"key":{"Fun":4},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["deallocate",0]}]},{"key":{"Fun":0},"value":[{"Ident":["box_free",0]},{"Ident":["main",0]}]}],"short_names":[{"key":{"TraitImpl":1},"value":[{"Impl":{"Trait":1}}]},{"key":{"Global":0},"value":[{"Impl":{"Trait":0}},{"Ident":["{vtable}",0]}]},{"key":{"Fun":6},"value":[{"Ident":["grow_zeroed",0]}]},{"key":{"Fun":3},"value":[{"Ident":["allocate_zeroed",0]}]},{"key":{"Fun":8},"value":[{"Impl":{"Trait":1}},{"Ident":["drop",0]}]},{"key":{"Fun":7},"value":[{"Ident":["shrink",0]}]},{"key":{"Fun":4},"value":[{"Ident":["deallocate",0]}]},{"key":{"Fun":5},"value":[{"Ident":["grow",0]}]},{"key":{"Fun":2},"value":[{"Ident":["allocate",0]}]},{"key":{"TraitImpl":0},"value":[{"Impl":{"Trait":0}}]},{"key":{"Fun":0},"value":[{"Ident":["main",0]}]},{"key":{"TraitDecl":0},"value":[{"Ident":["MetaSized",0]}]},{"key":{"TraitDecl":1},"value":[{"Ident":["Sized",0]}]},{"key":{"Global":1},"value":[{"Impl":{"Trait":1}},{"Ident":["{vtable}",0]}]},{"key":{"TraitDecl":3},"value":[{"Ident":["Drop",0]}]},{"key":{"TraitDecl":2},"value":[{"Ident":["Allocator",0]}]},{"key":{"Type":0},"value":[{"Ident":["Global",0]}]}],"files":[{"name":{"Local":"box_free.rs"},"crate_name":"box_free","contents":"fn main() {\n    let ptr: *const i32;\n    {\n        let x = Box::new(50);\n        ptr = &*x; // Convert box to raw pointer\n        // Box is freed here since borrowchecker does not keep track of raw pointer\n    }\n    #[allow(unused)]\n    let ub = unsafe {*ptr}; // Error Occurs Here\n}"},{"name":{"Local":"/rustc/library/alloc/src/boxed.rs"},"crate_name":"alloc","contents":null},{"name":{"Local":"/rustc/library/alloc/src/alloc.rs"},"crate_name":"alloc","contents":null},{"name":{"Local":"/rustc/library/alloc/src/lib.rs"},"crate_name":"alloc","contents":null},{"name":{"Local":"/rustc/library/core/src/marker.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/lib.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/alloc/mod.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/ops/drop.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/ops/mod.rs"},"crate_name":"core","contents":null}],"type_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Ident":["Global",0]}],"span":{"span":{"file_id":2,"beg":{"line":51,"col":0},"end":{"line":51,"col":17}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The global memory allocator."},{"DocComment":""},{"DocComment":" This type implements the [`Allocator`] trait by forwarding calls"},{"DocComment":" to the allocator registered with the `#[global_allocator]` attribute"},{"DocComment":" if there is one, or the `std` crate’s default."},{"DocComment":""},{"DocComment":" Note: while this type is unstable, the functionality it provides can be"},{"DocComment":" accessed through the [free functions in `alloc`](self#functions)."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"global_alloc_ty"},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"src":"TopLevel","kind":{"Struct":[]},"layout":{"size":0,"align":1,"discriminant_layout":null,"uninhabited":false,"variant_layouts":[{"field_offsets":[],"uninhabited":false,"tag":null}]},"ptr_metadata":"None"},null,null],"fun_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["box_free",0]},{"Ident":["main",0]}],"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":10,"col":1}},"generated_from_span":null},"source_text":"fn main() {\n    let ptr: *const i32;\n    {\n        let x = Box::new(50);\n        ptr = &*x; // Convert box to raw pointer\n        // Box is freed here since borrowchecker does not keep track of raw pointer\n    }\n    #[allow(unused)]\n    let ub = unsafe {*ptr}; // Error Occurs Here\n}","attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":true,"opacity":"Transparent","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":"TopLevel","is_global_initializer":null,"body":{"Ok":{"Unstructured":{"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":10,"col":1}},"generated_from_span":null},"locals":{"arg_count":0,"locals":[{"index":0,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":1,"name":"ptr","ty":{"RawPtr":[{"Literal":{"Int":"I32"}},"Shared"]}},{"index":2,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":3,"name":"x","ty":{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}},{"index":4,"name":null,"ty":{"RawPtr":[{"Literal":{"Int":"I32"}},"Shared"]}},{"index":5,"name":null,"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"index":6,"name":"ub","ty":{"Literal":{"Int":"I32"}}}]},"comments":[[7,["Box is freed here since borrowchecker does not keep track of raw pointer"]]],"body":[{"statements":[{"span":{"span":{"file_id":0,"beg":{"line":2,"col":8},"end":{"line":2,"col":11}},"generated_from_span":null},"content":{"StorageLive":1},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":3,"col":4},"end":{"line":7,"col":5}},"generated_from_span":null},"content":{"StorageLive":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":12},"end":{"line":4,"col":13}},"generated_from_span":null},"content":{"StorageLive":3},"comments_before":[]}],"terminator":{"span":{"span":{"file_id":0,"beg":{"line":4,"col":16},"end":{"line":4,"col":28}},"generated_from_span":null},"content":{"Call":{"call":{"func":{"Regular":{"func":{"Fun":{"Builtin":"BoxNew"}},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"args":[{"Const":{"value":{"Literal":{"Scalar":{"Signed":["I32","50"]}}},"ty":{"Literal":{"Int":"I32"}}}}],"dest":{"kind":{"Local":3},"ty":{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}}},"target":1,"on_unwind":2}},"comments_before":[]}},{"statements":[{"span":{"span":{"file_id":0,"beg":{"line":5,"col":14},"end":{"line":5,"col":17}},"generated_from_span":null},"content":{"StorageLive":4},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":14},"end":{"line":5,"col":17}},"generated_from_span":null},"content":{"StorageLive":5},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":14},"end":{"line":5,"col":17}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Local":5},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},{"Ref":[{"kind":{"Projection":[{"kind":{"Local":3},"ty":{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}},"Deref"]},"ty":{"Literal":{"Int":"I32"}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":14},"end":{"line":5,"col":17}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Local":4},"ty":{"RawPtr":[{"Literal":{"Int":"I32"}},"Shared"]}},{"RawPtr":[{"kind":{"Projection":[{"kind":{"Local":5},"ty":{"Ref":["Erased",{"Literal":{"Int":"I32"}},"Shared"]}},"Deref"]},"ty":{"Literal":{"Int":"I32"}}},"Shared"]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":8},"end":{"line":5,"col":17}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Local":1},"ty":{"RawPtr":[{"Literal":{"Int":"I32"}},"Shared"]}},{"Use":{"Move":{"kind":{"Local":4},"ty":{"RawPtr":[{"Literal":{"Int":"I32"}},"Shared"]}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":16},"end":{"line":5,"col":17}},"generated_from_span":null},"content":{"StorageDead":4},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":5,"col":17},"end":{"line":5,"col":18}},"generated_from_span":null},"content":{"StorageDead":5},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":4},"end":{"line":7,"col":5}},"generated_from_span":null},"content":{"Drop":[{"kind":{"Local":3},"ty":{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}},{"kind":{"TraitImpl":{"id":1,"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}},{"Adt":{"id":{"Adt":0},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"const_generics":[],"trait_refs":[null,null,null]}}},"trait_decl_ref":{"regions":[],"skip_binder":{"id":3,"generics":{"regions":[],"types":[{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}],"const_generics":[],"trait_refs":[]}}}}]},"comments_before":["Box is freed here since borrowchecker does not keep track of raw pointer"]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":4},"end":{"line":7,"col":5}},"generated_from_span":null},"content":{"StorageDead":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":7,"col":4},"end":{"line":7,"col":5}},"generated_from_span":null},"content":{"StorageDead":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":9,"col":8},"end":{"line":9,"col":10}},"generated_from_span":null},"content":{"StorageLive":6},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":9,"col":21},"end":{"line":9,"col":25}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Local":6},"ty":{"Literal":{"Int":"I32"}}},{"Use":{"Copy":{"kind":{"Projection":[{"kind":{"Local":1},"ty":{"RawPtr":[{"Literal":{"Int":"I32"}},"Shared"]}},"Deref"]},"ty":{"Literal":{"Int":"I32"}}}}}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":1,"col":10},"end":{"line":10,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Local":0},"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"Aggregate":[{"Adt":[{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},null,null]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":0},"end":{"line":10,"col":1}},"generated_from_span":null},"content":{"StorageDead":6},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":0},"end":{"line":10,"col":1}},"generated_from_span":null},"content":{"StorageDead":1},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":10,"col":1},"end":{"line":10,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Local":0},"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"Aggregate":[{"Adt":[{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},null,null]},[]]}]},"comments_before":[]}],"terminator":{"span":{"span":{"file_id":0,"beg":{"line":10,"col":1},"end":{"line":10,"col":1}},"generated_from_span":null},"content":"Return","comments_before":[]}},{"statements":[],"terminator":{"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":10,"col":1}},"generated_from_span":null},"content":"UnwindResume","comments_before":[]}}]}}}},{"def_id":1,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["drop",0]},{"Ident":["Drop",0]},{"Ident":["drop",0]}],"span":{"span":{"file_id":7,"beg":{"line":241,"col":4},"end":{"line":241,"col":23}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Executes the destructor for this type."},{"DocComment":""},{"DocComment":" This method is called implicitly when the value goes out of scope,"},{"DocComment":" and cannot be called explicitly (this is compiler error [E0040])."},{"DocComment":" However, the [`mem::drop`] function in the prelude can be"},{"DocComment":" used to call the argument's `Drop` implementation."},{"DocComment":""},{"DocComment":" When this method has been called, `self` has not yet been deallocated."},{"DocComment":" That only happens after the method is over."},{"DocComment":" If this wasn't the case, `self` would be a dangling reference."},{"DocComment":""},{"DocComment":" # Panics"},{"DocComment":""},{"DocComment":" Implementations should generally avoid [`panic!`]ing, because `drop()` may itself be called"},{"DocComment":" during unwinding due to a panic, and if the `drop()` panics in that situation (a “double"},{"DocComment":" panic”), this will likely abort the program. It is possible to check [`panicking()`] first,"},{"DocComment":" which may be desirable for a `Drop` implementation that is reporting a bug of the kind"},{"DocComment":" “you didn't finish using this before it was dropped”; but most types should simply clean up"},{"DocComment":" their owned allocations or other resources and return normally from `drop()`, regardless of"},{"DocComment":" what state they are in."},{"DocComment":""},{"DocComment":" Note that even if this panics, the value is considered to be dropped;"},{"DocComment":" you must not cause `drop` to be called again. This is normally automatically"},{"DocComment":" handled by the compiler, but when using unsafe code, can sometimes occur"},{"DocComment":" unintentionally, particularly when using [`ptr::drop_in_place`]."},{"DocComment":""},{"DocComment":" [E0040]: ../../error_codes/E0040.html"},{"DocComment":" [`panic!`]: crate::panic!"},{"DocComment":" [`panicking()`]: ../../std/thread/fn.panicking.html"},{"DocComment":" [`mem::drop`]: drop"},{"DocComment":" [`ptr::drop_in_place`]: crate::ptr::drop_in_place"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[{"clause_id":0,"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":1,"col":0}},"generated_from_span":null},"origin":"WhereClauseOnFn","trait_":{"regions":[],"skip_binder":{"id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"TypeVar":{"Free":0}},"Mut"]}],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitDecl":{"trait_ref":{"id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}},"item_name":"drop","has_default":false}},"is_global_initializer":null,"body":{"Err":null}},null,null,null,null,null,null,{"def_id":8,"item_meta":{"name":[{"Ident":["alloc",0]},{"Ident":["boxed",0]},{"Impl":{"Trait":1}},{"Ident":["drop",0]}],"span":{"span":{"file_id":1,"beg":{"line":1658,"col":4},"end":{"line":1658,"col":22}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[{"index":0,"name":null}],"types":[{"index":0,"name":"T"},{"index":1,"name":"A"}],"const_generics":[],"trait_clauses":[null,null,null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"Ref":[{"Var":{"Free":0}},{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null,null,null]}}},"Mut"]}],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":{"TraitImpl":{"impl_ref":{"id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null,null,null]}},"trait_ref":{"id":3,"generics":{"regions":[],"types":[{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null,null,null]}}}],"const_generics":[],"trait_refs":[]}},"item_name":"drop","reuses_default":true}},"is_global_initializer":null,"body":{"Err":null}}],"global_decls":[null,null],"trait_decls":[null,null,null,{"def_id":3,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["ops",0]},{"Ident":["drop",0]},{"Ident":["Drop",0]}],"span":{"span":{"file_id":7,"beg":{"line":208,"col":0},"end":{"line":208,"col":14}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Custom code within the destructor."},{"DocComment":""},{"DocComment":" When a value is no longer needed, Rust will run a \"destructor\" on that value."},{"DocComment":" The most common way that a value is no longer needed is when it goes out of"},{"DocComment":" scope. Destructors may still run in other circumstances, but we're going to"},{"DocComment":" focus on scope for the examples here. To learn about some of those other cases,"},{"DocComment":" please see [the reference] section on destructors."},{"DocComment":""},{"DocComment":" [the reference]: https://doc.rust-lang.org/reference/destructors.html"},{"DocComment":""},{"DocComment":" This destructor consists of two components:"},{"DocComment":" - A call to `Drop::drop` for that value, if this special `Drop` trait is implemented for its type."},{"DocComment":" - The automatically generated \"drop glue\" which recursively calls the destructors"},{"DocComment":"     of all the fields of this value."},{"DocComment":""},{"DocComment":" As Rust automatically calls the destructors of all contained fields,"},{"DocComment":" you don't have to implement `Drop` in most cases. But there are some cases where"},{"DocComment":" it is useful, for example for types which directly manage a resource."},{"DocComment":" That resource may be memory, it may be a file descriptor, it may be a network socket."},{"DocComment":" Once a value of that type is no longer going to be used, it should \"clean up\" its"},{"DocComment":" resource by freeing the memory or closing the file or socket. This is"},{"DocComment":" the job of a destructor, and therefore the job of `Drop::drop`."},{"DocComment":""},{"DocComment":" ## Examples"},{"DocComment":""},{"DocComment":" To see destructors in action, let's take a look at the following program:"},{"DocComment":""},{"DocComment":" ```rust"},{"DocComment":" struct HasDrop;"},{"DocComment":""},{"DocComment":" impl Drop for HasDrop {"},{"DocComment":"     fn drop(&mut self) {"},{"DocComment":"         println!(\"Dropping HasDrop!\");"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" struct HasTwoDrops {"},{"DocComment":"     one: HasDrop,"},{"DocComment":"     two: HasDrop,"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" impl Drop for HasTwoDrops {"},{"DocComment":"     fn drop(&mut self) {"},{"DocComment":"         println!(\"Dropping HasTwoDrops!\");"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" fn main() {"},{"DocComment":"     let _x = HasTwoDrops { one: HasDrop, two: HasDrop };"},{"DocComment":"     println!(\"Running!\");"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Rust will first call `Drop::drop` for `_x` and then for both `_x.one` and `_x.two`,"},{"DocComment":" meaning that running this will print"},{"DocComment":""},{"DocComment":" ```text"},{"DocComment":" Running!"},{"DocComment":" Dropping HasTwoDrops!"},{"DocComment":" Dropping HasDrop!"},{"DocComment":" Dropping HasDrop!"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Even if we remove the implementation of `Drop` for `HasTwoDrop`, the destructors of its fields are still called."},{"DocComment":" This would result in"},{"DocComment":""},{"DocComment":" ```test"},{"DocComment":" Running!"},{"DocComment":" Dropping HasDrop!"},{"DocComment":" Dropping HasDrop!"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" ## You cannot call `Drop::drop` yourself"},{"DocComment":""},{"DocComment":" Because `Drop::drop` is used to clean up a value, it may be dangerous to use this value after"},{"DocComment":" the method has been called. As `Drop::drop` does not take ownership of its input,"},{"DocComment":" Rust prevents misuse by not allowing you to call `Drop::drop` directly."},{"DocComment":""},{"DocComment":" In other words, if you tried to explicitly call `Drop::drop` in the above example, you'd get a compiler error."},{"DocComment":""},{"DocComment":" If you'd like to explicitly call the destructor of a value, [`mem::drop`] can be used instead."},{"DocComment":""},{"DocComment":" [`mem::drop`]: drop"},{"DocComment":""},{"DocComment":" ## Drop order"},{"DocComment":""},{"DocComment":" Which of our two `HasDrop` drops first, though? For structs, it's the same"},{"DocComment":" order that they're declared: first `one`, then `two`. If you'd like to try"},{"DocComment":" this yourself, you can modify `HasDrop` above to contain some data, like an"},{"DocComment":" integer, and then use it in the `println!` inside of `Drop`. This behavior is"},{"DocComment":" guaranteed by the language."},{"DocComment":""},{"DocComment":" Unlike for structs, local variables are dropped in reverse order:"},{"DocComment":""},{"DocComment":" ```rust"},{"DocComment":" struct Foo;"},{"DocComment":""},{"DocComment":" impl Drop for Foo {"},{"DocComment":"     fn drop(&mut self) {"},{"DocComment":"         println!(\"Dropping Foo!\")"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" struct Bar;"},{"DocComment":""},{"DocComment":" impl Drop for Bar {"},{"DocComment":"     fn drop(&mut self) {"},{"DocComment":"         println!(\"Dropping Bar!\")"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" fn main() {"},{"DocComment":"     let _foo = Foo;"},{"DocComment":"     let _bar = Bar;"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" This will print"},{"DocComment":""},{"DocComment":" ```text"},{"DocComment":" Dropping Bar!"},{"DocComment":" Dropping Foo!"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" Please see [the reference] for the full rules."},{"DocComment":""},{"DocComment":" [the reference]: https://doc.rust-lang.org/reference/destructors.html"},{"DocComment":""},{"DocComment":" ## `Copy` and `Drop` are exclusive"},{"DocComment":""},{"DocComment":" You cannot implement both [`Copy`] and `Drop` on the same type. Types that"},{"DocComment":" are `Copy` get implicitly duplicated by the compiler, making it very"},{"DocComment":" hard to predict when, and how often destructors will be executed. As such,"},{"DocComment":" these types cannot have destructors."},{"DocComment":""},{"DocComment":" ## Drop check"},{"DocComment":""},{"DocComment":" Dropping interacts with the borrow checker in subtle ways: when a type `T` is being implicitly"},{"DocComment":" dropped as some variable of this type goes out of scope, the borrow checker needs to ensure that"},{"DocComment":" calling `T`'s destructor at this moment is safe. In particular, it also needs to be safe to"},{"DocComment":" recursively drop all the fields of `T`. For example, it is crucial that code like the following"},{"DocComment":" is being rejected:"},{"DocComment":""},{"DocComment":" ```compile_fail,E0597"},{"DocComment":" use std::cell::Cell;"},{"DocComment":""},{"DocComment":" struct S<'a>(Cell<Option<&'a S<'a>>>, Box<i32>);"},{"DocComment":" impl Drop for S<'_> {"},{"DocComment":"     fn drop(&mut self) {"},{"DocComment":"         if let Some(r) = self.0.get() {"},{"DocComment":"             // Print the contents of the `Box` in `r`."},{"DocComment":"             println!(\"{}\", r.1);"},{"DocComment":"         }"},{"DocComment":"     }"},{"DocComment":" }"},{"DocComment":""},{"DocComment":" fn main() {"},{"DocComment":"     // Set up two `S` that point to each other."},{"DocComment":"     let s1 = S(Cell::new(None), Box::new(42));"},{"DocComment":"     let s2 = S(Cell::new(Some(&s1)), Box::new(42));"},{"DocComment":"     s1.0.set(Some(&s2));"},{"DocComment":"     // Now they both get dropped. But whichever is the 2nd one"},{"DocComment":"     // to be dropped will access the `Box` in the first one,"},{"DocComment":"     // which is a use-after-free!"},{"DocComment":" }"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" The Nomicon discusses the need for [drop check in more detail][drop check]."},{"DocComment":""},{"DocComment":" To reject such code, the \"drop check\" analysis determines which types and lifetimes need to"},{"DocComment":" still be live when `T` gets dropped. The exact details of this analysis are not yet"},{"DocComment":" stably guaranteed and **subject to change**. Currently, the analysis works as follows:"},{"DocComment":" - If `T` has no drop glue, then trivially nothing is required to be live. This is the case if"},{"DocComment":"   neither `T` nor any of its (recursive) fields have a destructor (`impl Drop`). [`PhantomData`],"},{"DocComment":"   arrays of length 0 and [`ManuallyDrop`] are considered to never have a destructor, no matter"},{"DocComment":"   their field type."},{"DocComment":" - If `T` has drop glue, then, for all types `U` that are *owned* by any field of `T`,"},{"DocComment":"   recursively add the types and lifetimes that need to be live when `U` gets dropped. The set of"},{"DocComment":"   owned types is determined by recursively traversing `T`:"},{"DocComment":"   - Recursively descend through `PhantomData`, `Box`, tuples, and arrays (excluding arrays of"},{"DocComment":"     length 0)."},{"DocComment":"   - Stop at reference and raw pointer types as well as function pointers and function items;"},{"DocComment":"     they do not own anything."},{"DocComment":"   - Stop at non-composite types (type parameters that remain generic in the current context and"},{"DocComment":"     base types such as integers and `bool`); these types are owned."},{"DocComment":"   - When hitting an ADT with `impl Drop`, stop there; this type is owned."},{"DocComment":"   - When hitting an ADT without `impl Drop`, recursively descend to its fields. (For an `enum`,"},{"DocComment":"     consider all fields of all variants.)"},{"DocComment":" - Furthermore, if `T` implements `Drop`, then all generic (lifetime and type) parameters of `T`"},{"DocComment":"   must be live."},{"DocComment":""},{"DocComment":" In the above example, the last clause implies that `'a` must be live when `S<'a>` is dropped,"},{"DocComment":" and hence the example is rejected. If we remove the `impl Drop`, the liveness requirement"},{"DocComment":" disappears and the example is accepted."},{"DocComment":""},{"DocComment":" There exists an unstable way for a type to opt-out of the last clause; this is called \"drop"},{"DocComment":" check eyepatch\" or `may_dangle`. For more details on this nightly-only feature, see the"},{"DocComment":" [discussion in the Nomicon][nomicon]."},{"DocComment":""},{"DocComment":" [`ManuallyDrop`]: crate::mem::ManuallyDrop"},{"DocComment":" [`PhantomData`]: crate::marker::PhantomData"},{"DocComment":" [drop check]: ../../nomicon/dropck.html"},{"DocComment":" [nomicon]: ../../nomicon/phantom-data.html#an-exception-the-special-case-of-the-standard-library-and-its-unstable-may_dangle"}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Foreign","lang_item":"drop"},"generics":{"regions":[],"types":[{"index":0,"name":"Self"}],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_clauses":[null],"consts":[],"const_defaults":{},"types":[],"type_defaults":{},"type_clauses":[],"methods":[["drop",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":1,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[{"kind":"SelfId","trait_decl_ref":{"regions":[],"skip_binder":{"id":3,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[]}}}}]}},"kind":{"TraitMethod":[3,"drop"]}}]],"vtable":{"id":{"Adt":1},"generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}],"trait_impls":[null,{"def_id":1,"item_meta":{"name":[{"Ident":["alloc",0]},{"Ident":["boxed",0]},{"Impl":{"Trait":1}}],"span":{"span":{"file_id":1,"beg":{"line":1656,"col":0},"end":{"line":1656,"col":69}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":false,"opacity":"Foreign","lang_item":null},"impl_trait":{"id":3,"generics":{"regions":[],"types":[{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}}],"const_generics":[],"trait_refs":[null,null,null]}}}],"const_generics":[],"trait_refs":[]}},"generics":{"regions":[],"types":[{"index":0,"name":"T"},{"index":1,"name":"A"}],"const_generics":[],"trait_clauses":[null,null,null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"parent_trait_refs":[null],"consts":[],"types":[],"type_clauses":[],"methods":[["drop",{"params":{"regions":[{"index":0,"name":null}],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"skip_binder":{"id":8,"generics":{"regions":[{"Var":{"Bound":[0,0]}}],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null,null,null]}},"kind":{"TraitMethod":[3,"drop"]}}]],"vtable":{"id":1,"generics":{"regions":[],"types":[{"TypeVar":{"Free":0}},{"TypeVar":{"Free":1}}],"const_generics":[],"trait_refs":[null,null,null]}}}],"ordered_decls":[{"TraitDecl":{"NonRec":3}},{"Fun":{"NonRec":1}},{"Type":{"NonRec":0}},{"Fun":{"NonRec":8}},{"TraitImpl":{"NonRec":1}},{"Fun":{"NonRec":0}}]}}