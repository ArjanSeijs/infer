{"charon_version":"0.1.123","translated":{"crate_name":"box_leak","options":{"ullbc":true,"lib":false,"bin":null,"mir_promoted":false,"mir_optimized":false,"mir":"Elaborated","input_file":null,"read_llbc":null,"dest_dir":null,"dest_file":"box_leak.rs.ullbc","use_polonius":false,"skip_borrowck":false,"monomorphize":false,"monomorphize_conservative":false,"extract_opaque_bodies":true,"translate_all_methods":false,"include":["std::mem::forget"],"opaque":[],"exclude":[],"remove_associated_types":[],"hide_marker_traits":true,"hide_allocator":true,"remove_unused_self_clauses":false,"add_drop_bounds":false,"start_from":[],"no_cargo":false,"rustc_args":[],"cargo_args":[],"abort_on_error":false,"error_on_warnings":false,"no_serialize":false,"print_original_ullbc":false,"print_ullbc":true,"print_built_llbc":false,"print_llbc":false,"no_merge_goto_chains":false,"no_ops_to_function_calls":false,"raw_boxes":false,"preset":null},"target_information":{"target_pointer_size":8,"is_little_endian":true},"item_names":[{"key":{"TraitImpl":0},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}}]},{"key":{"TraitDecl":1},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["Sized",0]}]},{"key":{"Type":0},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Ident":["Global",0]}]},{"key":{"Type":1},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["MetaSized",0]},{"Ident":["{vtable}",0]}]},{"key":{"Global":0},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["{vtable}",0]}]},{"key":{"Fun":1},"value":[{"Ident":["core",0]},{"Ident":["mem",0]},{"Ident":["forget",0]}]},{"key":{"Fun":2},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["allocate",0]}]},{"key":{"TraitDecl":0},"value":[{"Ident":["core",0]},{"Ident":["marker",0]},{"Ident":["MetaSized",0]}]},{"key":{"TraitDecl":2},"value":[{"Ident":["core",0]},{"Ident":["alloc",0]},{"Ident":["Allocator",0]}]},{"key":{"Fun":7},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["shrink",0]}]},{"key":{"Fun":6},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["grow_zeroed",0]}]},{"key":{"Fun":5},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["grow",0]}]},{"key":{"Fun":3},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["allocate_zeroed",0]}]},{"key":{"Fun":0},"value":[{"Ident":["box_leak",0]},{"Ident":["main",0]}]},{"key":{"Fun":4},"value":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Impl":{"Trait":0}},{"Ident":["deallocate",0]}]}],"short_names":[{"key":{"Fun":4},"value":[{"Ident":["deallocate",0]}]},{"key":{"Global":0},"value":[{"Impl":{"Trait":0}},{"Ident":["{vtable}",0]}]},{"key":{"TraitDecl":1},"value":[{"Ident":["Sized",0]}]},{"key":{"Fun":0},"value":[{"Ident":["main",0]}]},{"key":{"Fun":3},"value":[{"Ident":["allocate_zeroed",0]}]},{"key":{"Fun":1},"value":[{"Ident":["forget",0]}]},{"key":{"Fun":2},"value":[{"Ident":["allocate",0]}]},{"key":{"TraitDecl":2},"value":[{"Ident":["Allocator",0]}]},{"key":{"TraitDecl":0},"value":[{"Ident":["MetaSized",0]}]},{"key":{"Fun":6},"value":[{"Ident":["grow_zeroed",0]}]},{"key":{"TraitImpl":0},"value":[{"Impl":{"Trait":0}}]},{"key":{"Type":0},"value":[{"Ident":["Global",0]}]},{"key":{"Fun":5},"value":[{"Ident":["grow",0]}]},{"key":{"Fun":7},"value":[{"Ident":["shrink",0]}]}],"files":[{"name":{"Local":"box_leak.rs"},"crate_name":"box_leak","contents":"fn main() {\n    let b = Box::new(42);\n    std::mem::forget(b);\n}"},{"name":{"Local":"/rustc/library/alloc/src/boxed.rs"},"crate_name":"alloc","contents":null},{"name":{"Local":"/rustc/library/alloc/src/alloc.rs"},"crate_name":"alloc","contents":null},{"name":{"Local":"/rustc/library/alloc/src/lib.rs"},"crate_name":"alloc","contents":null},{"name":{"Local":"/rustc/library/core/src/marker.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/lib.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/alloc/mod.rs"},"crate_name":"core","contents":null},{"name":{"Local":"/rustc/library/core/src/mem/mod.rs"},"crate_name":"core","contents":null}],"type_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["alloc",0]},{"Ident":["alloc",0]},{"Ident":["Global",0]}],"span":{"span":{"file_id":2,"beg":{"line":51,"col":0},"end":{"line":51,"col":17}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" The global memory allocator."},{"DocComment":""},{"DocComment":" This type implements the [`Allocator`] trait by forwarding calls"},{"DocComment":" to the allocator registered with the `#[global_allocator]` attribute"},{"DocComment":" if there is one, or the `std` crate’s default."},{"DocComment":""},{"DocComment":" Note: while this type is unstable, the functionality it provides can be"},{"DocComment":" accessed through the [free functions in `alloc`](self#functions)."}],"inline":null,"rename":null,"public":true},"is_local":false,"opacity":"Transparent","lang_item":"global_alloc_ty"},"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"src":"TopLevel","kind":{"Struct":[]},"layout":{"size":0,"align":1,"discriminant_layout":null,"uninhabited":false,"variant_layouts":[{"field_offsets":[],"uninhabited":false,"tag":null}]},"ptr_metadata":"None"},null],"fun_decls":[{"def_id":0,"item_meta":{"name":[{"Ident":["box_leak",0]},{"Ident":["main",0]}],"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":4,"col":1}},"generated_from_span":null},"source_text":"fn main() {\n    let b = Box::new(42);\n    std::mem::forget(b);\n}","attr_info":{"attributes":[],"inline":null,"rename":null,"public":false},"is_local":true,"opacity":"Transparent","lang_item":null},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[],"const_generics":[],"trait_clauses":[],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":"TopLevel","is_global_initializer":null,"body":{"Ok":{"Unstructured":{"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":4,"col":1}},"generated_from_span":null},"locals":{"arg_count":0,"locals":[{"index":0,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":1,"name":"b","ty":{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}},{"index":2,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":3,"name":null,"ty":{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}}]},"comments":[],"body":[{"statements":[{"span":{"span":{"file_id":0,"beg":{"line":2,"col":8},"end":{"line":2,"col":9}},"generated_from_span":null},"content":{"StorageLive":1},"comments_before":[]}],"terminator":{"span":{"span":{"file_id":0,"beg":{"line":2,"col":12},"end":{"line":2,"col":24}},"generated_from_span":null},"content":{"Call":{"call":{"func":{"Regular":{"func":{"Fun":{"Builtin":"BoxNew"}},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null]}}},"args":[{"Const":{"value":{"Literal":{"Scalar":{"Signed":["I32","42"]}}},"ty":{"Literal":{"Int":"I32"}}}}],"dest":{"kind":{"Local":1},"ty":{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}}},"target":1,"on_unwind":2}},"comments_before":[]}},{"statements":[{"span":{"span":{"file_id":0,"beg":{"line":3,"col":4},"end":{"line":3,"col":23}},"generated_from_span":null},"content":{"StorageLive":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":3,"col":21},"end":{"line":3,"col":22}},"generated_from_span":null},"content":{"StorageLive":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":3,"col":21},"end":{"line":3,"col":22}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Local":3},"ty":{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}},{"Use":{"Move":{"kind":{"Local":1},"ty":{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}}}}]},"comments_before":[]}],"terminator":{"span":{"span":{"file_id":0,"beg":{"line":3,"col":4},"end":{"line":3,"col":23}},"generated_from_span":null},"content":{"Call":{"call":{"func":{"Regular":{"func":{"Fun":{"Regular":1}},"generics":{"regions":[],"types":[{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}],"const_generics":[],"trait_refs":[null]}}},"args":[{"Move":{"kind":{"Local":3},"ty":{"Adt":{"id":{"Builtin":"Box"},"generics":{"regions":[],"types":[{"Literal":{"Int":"I32"}}],"const_generics":[],"trait_refs":[null,null,null]}}}}}],"dest":{"kind":{"Local":2},"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}}},"target":3,"on_unwind":4}},"comments_before":[]}},{"statements":[],"terminator":{"span":{"span":{"file_id":0,"beg":{"line":2,"col":12},"end":{"line":2,"col":24}},"generated_from_span":null},"content":"UnwindResume","comments_before":[]}},{"statements":[{"span":{"span":{"file_id":0,"beg":{"line":3,"col":22},"end":{"line":3,"col":23}},"generated_from_span":null},"content":{"StorageDead":3},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":3,"col":23},"end":{"line":3,"col":24}},"generated_from_span":null},"content":{"StorageDead":2},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":1,"col":10},"end":{"line":4,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Local":0},"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"Aggregate":[{"Adt":[{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},null,null]},[]]}]},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":0},"end":{"line":4,"col":1}},"generated_from_span":null},"content":{"StorageDead":1},"comments_before":[]},{"span":{"span":{"file_id":0,"beg":{"line":4,"col":1},"end":{"line":4,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Local":0},"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"Aggregate":[{"Adt":[{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},null,null]},[]]}]},"comments_before":[]}],"terminator":{"span":{"span":{"file_id":0,"beg":{"line":4,"col":1},"end":{"line":4,"col":1}},"generated_from_span":null},"content":"Return","comments_before":[]}},{"statements":[],"terminator":{"span":{"span":{"file_id":0,"beg":{"line":1,"col":0},"end":{"line":4,"col":1}},"generated_from_span":null},"content":"UnwindResume","comments_before":[]}}]}}}},{"def_id":1,"item_meta":{"name":[{"Ident":["core",0]},{"Ident":["mem",0]},{"Ident":["forget",0]}],"span":{"span":{"file_id":7,"beg":{"line":146,"col":0},"end":{"line":146,"col":28}},"generated_from_span":null},"source_text":null,"attr_info":{"attributes":[{"DocComment":" Takes ownership and \"forgets\" about the value **without running its destructor**."},{"DocComment":""},{"DocComment":" Any resources the value manages, such as heap memory or a file handle, will linger"},{"DocComment":" forever in an unreachable state. However, it does not guarantee that pointers"},{"DocComment":" to this memory will remain valid."},{"DocComment":""},{"DocComment":" * If you want to leak memory, see [`Box::leak`]."},{"DocComment":" * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`]."},{"DocComment":" * If you want to dispose of a value properly, running its destructor, see"},{"DocComment":" [`mem::drop`]."},{"DocComment":""},{"DocComment":" # Safety"},{"DocComment":""},{"DocComment":" `forget` is not marked as `unsafe`, because Rust's safety guarantees"},{"DocComment":" do not include a guarantee that destructors will always run. For example,"},{"DocComment":" a program can create a reference cycle using [`Rc`][rc], or call"},{"DocComment":" [`process::exit`][exit] to exit without running destructors. Thus, allowing"},{"DocComment":" `mem::forget` from safe code does not fundamentally change Rust's safety"},{"DocComment":" guarantees."},{"DocComment":""},{"DocComment":" That said, leaking resources such as memory or I/O objects is usually undesirable."},{"DocComment":" The need comes up in some specialized use cases for FFI or unsafe code, but even"},{"DocComment":" then, [`ManuallyDrop`] is typically preferred."},{"DocComment":""},{"DocComment":" Because forgetting a value is allowed, any `unsafe` code you write must"},{"DocComment":" allow for this possibility. You cannot return a value and expect that the"},{"DocComment":" caller will necessarily run the value's destructor."},{"DocComment":""},{"DocComment":" [rc]: ../../std/rc/struct.Rc.html"},{"DocComment":" [exit]: ../../std/process/fn.exit.html"},{"DocComment":""},{"DocComment":" # Examples"},{"DocComment":""},{"DocComment":" The canonical safe use of `mem::forget` is to circumvent a value's destructor"},{"DocComment":" implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim"},{"DocComment":" the space taken by the variable but never close the underlying system resource:"},{"DocComment":""},{"DocComment":" ```no_run"},{"DocComment":" use std::mem;"},{"DocComment":" use std::fs::File;"},{"DocComment":""},{"DocComment":" let file = File::open(\"foo.txt\").unwrap();"},{"DocComment":" mem::forget(file);"},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" This is useful when the ownership of the underlying resource was previously"},{"DocComment":" transferred to code outside of Rust, for example by transmitting the raw"},{"DocComment":" file descriptor to C code."},{"DocComment":""},{"DocComment":" # Relationship with `ManuallyDrop`"},{"DocComment":""},{"DocComment":" While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone."},{"DocComment":" [`ManuallyDrop`] should be used instead. Consider, for example, this code:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::mem;"},{"DocComment":""},{"DocComment":" let mut v = vec![65, 122];"},{"DocComment":" // Build a `String` using the contents of `v`"},{"DocComment":" let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };"},{"DocComment":" // leak `v` because its memory is now managed by `s`"},{"DocComment":" mem::forget(v);  // ERROR - v is invalid and must not be passed to a function"},{"DocComment":" assert_eq!(s, \"Az\");"},{"DocComment":" // `s` is implicitly dropped and its memory deallocated."},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" There are two issues with the above example:"},{"DocComment":""},{"DocComment":" * If more code were added between the construction of `String` and the invocation of"},{"DocComment":"   `mem::forget()`, a panic within it would cause a double free because the same memory"},{"DocComment":"   is handled by both `v` and `s`."},{"DocComment":" * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,"},{"DocComment":"   the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won't"},{"DocComment":"   inspect it), some types have strict requirements on their values that"},{"DocComment":"   make them invalid when dangling or no longer owned. Using invalid values in any"},{"DocComment":"   way, including passing them to or returning them from functions, constitutes"},{"DocComment":"   undefined behavior and may break the assumptions made by the compiler."},{"DocComment":""},{"DocComment":" Switching to `ManuallyDrop` avoids both issues:"},{"DocComment":""},{"DocComment":" ```"},{"DocComment":" use std::mem::ManuallyDrop;"},{"DocComment":""},{"DocComment":" let v = vec![65, 122];"},{"DocComment":" // Before we disassemble `v` into its raw parts, make sure it"},{"DocComment":" // does not get dropped!"},{"DocComment":" let mut v = ManuallyDrop::new(v);"},{"DocComment":" // Now disassemble `v`. These operations cannot panic, so there cannot be a leak."},{"DocComment":" let (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());"},{"DocComment":" // Finally, build a `String`."},{"DocComment":" let s = unsafe { String::from_raw_parts(ptr, len, cap) };"},{"DocComment":" assert_eq!(s, \"Az\");"},{"DocComment":" // `s` is implicitly dropped and its memory deallocated."},{"DocComment":" ```"},{"DocComment":""},{"DocComment":" `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor"},{"DocComment":" before doing anything else. `mem::forget()` doesn't allow this because it consumes its"},{"DocComment":" argument, forcing us to call it only after extracting anything we need from `v`. Even"},{"DocComment":" if a panic were introduced between construction of `ManuallyDrop` and building the"},{"DocComment":" string (which cannot happen in the code as shown), it would result in a leak and not a"},{"DocComment":" double free. In other words, `ManuallyDrop` errs on the side of leaking instead of"},{"DocComment":" erring on the side of (double-)dropping."},{"DocComment":""},{"DocComment":" Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the"},{"DocComment":" ownership to `s` — the final step of interacting with `v` to dispose of it without"},{"DocComment":" running its destructor is entirely avoided."},{"DocComment":""},{"DocComment":" [`Box`]: ../../std/boxed/struct.Box.html"},{"DocComment":" [`Box::leak`]: ../../std/boxed/struct.Box.html#method.leak"},{"DocComment":" [`Box::into_raw`]: ../../std/boxed/struct.Box.html#method.into_raw"},{"DocComment":" [`mem::drop`]: drop"},{"DocComment":" [ub]: ../../reference/behavior-considered-undefined.html"},{"Unknown":{"path":"rustc_diagnostic_item","args":"\"mem_forget\""}}],"inline":"Hint","rename":null,"public":true},"is_local":false,"opacity":"Transparent","lang_item":"mem_forget"},"signature":{"is_unsafe":false,"generics":{"regions":[],"types":[{"index":0,"name":"T"}],"const_generics":[],"trait_clauses":[null],"regions_outlive":[],"types_outlive":[],"trait_type_constraints":[]},"inputs":[{"TypeVar":{"Free":0}}],"output":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},"kind":"TopLevel","is_global_initializer":null,"body":{"Ok":{"Unstructured":{"span":{"span":{"file_id":7,"beg":{"line":146,"col":0},"end":{"line":148,"col":1}},"generated_from_span":null},"locals":{"arg_count":1,"locals":[{"index":0,"name":null,"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"index":1,"name":"t","ty":{"TypeVar":{"Free":0}}}]},"comments":[],"body":[{"statements":[{"span":{"span":{"file_id":7,"beg":{"line":148,"col":1},"end":{"line":148,"col":1}},"generated_from_span":null},"content":{"Assign":[{"kind":{"Local":0},"ty":{"Adt":{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}}}},{"Aggregate":[{"Adt":[{"id":"Tuple","generics":{"regions":[],"types":[],"const_generics":[],"trait_refs":[]}},null,null]},[]]}]},"comments_before":[]}],"terminator":{"span":{"span":{"file_id":7,"beg":{"line":148,"col":1},"end":{"line":148,"col":1}},"generated_from_span":null},"content":"Return","comments_before":[]}}]}}}},null,null,null,null,null,null],"global_decls":[null],"trait_decls":[null,null,null],"trait_impls":[null],"ordered_decls":[{"Fun":{"NonRec":1}},{"Type":{"NonRec":0}},{"Fun":{"NonRec":0}}]}}