# Final ULLBC before control-flow reconstruction:

// Full name: alloc::string::String
#[lang_item("String")]
pub opaque type String

// Full name: core::ops::range::Range
#[lang_item("Range")]
pub struct Range<Idx>
where
    [@TraitClause0]: Sized<Idx>,
{
  start: Idx,
  end: Idx,
}

// Full name: core::option::Option
#[lang_item("Option")]
pub enum Option<T>
where
    [@TraitClause0]: Sized<T>,
{
  None,
  Some(T),
}

// Full name: core::cmp::Ordering
#[lang_item("Ordering")]
pub enum Ordering {
  Less,
  Equal,
  Greater,
}

// Full name: core::ops::control_flow::ControlFlow
#[lang_item("ControlFlow")]
pub enum ControlFlow<B, C>
where
    [@TraitClause0]: Sized<B>,
    [@TraitClause1]: Sized<C>,
{
  Continue(C),
  Break(B),
}

// Full name: core::marker::Sized
#[lang_item("sized")]
pub trait Sized<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    non-dyn-compatible
}

// Full name: core::marker::MetaSized
#[lang_item("meta_sized")]
pub trait MetaSized<Self>

// Full name: core::convert::From
#[lang_item("From")]
pub trait From<Self, T>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<T>
    fn from = core::convert::From::from<Self, T>[Self]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::IntoIterator
#[lang_item("IntoIterator")]
pub trait IntoIterator<Self>
where
    Self::parent_clause3::Item = Self::Item,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    parent_clause2 : [@TraitClause2]: Sized<Self::IntoIter>
    parent_clause3 : [@TraitClause3]: Iterator<Self::IntoIter>
    type Item
    type IntoIter
    fn into_iter = core::iter::traits::collect::IntoIterator::into_iter<Self>[Self]
    non-dyn-compatible
}

// Full name: core::iter::traits::iterator::Iterator
#[lang_item("iterator")]
pub trait Iterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Self::Item>
    type Item
    fn next<'_0> = core::iter::traits::iterator::Iterator::next<'_0_0, Self>[Self]
    non-dyn-compatible
}

// Full name: core::iter::range::Step
#[lang_item("range_step")]
pub trait Step<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    parent_clause2 : [@TraitClause2]: PartialOrd<Self, Self>
    fn steps_between<'_0, '_1> = core::iter::range::Step::steps_between<'_0_0, '_0_1, Self>[Self]
    fn forward_checked = core::iter::range::Step::forward_checked<Self>[Self]
    fn backward_checked = core::iter::range::Step::backward_checked<Self>[Self]
    non-dyn-compatible
}

// Full name: core::ops::drop::Drop
#[lang_item("drop")]
pub trait Drop<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    fn drop<'_0> = core::ops::drop::Drop::drop<'_0_0, Self>[Self]
    vtable: core::ops::drop::Drop::{vtable}
}

// Full name: core::clone::Clone
#[lang_item("clone")]
pub trait Clone<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn clone<'_0> = core::clone::Clone::clone<'_0_0, Self>[Self]
    non-dyn-compatible
}

// Full name: core::marker::Destruct
#[lang_item("destruct")]
pub trait Destruct<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Destruct::{vtable}
}

// Full name: core::cmp::PartialOrd
#[lang_item("partial_ord")]
pub trait PartialOrd<Self, Rhs>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Rhs>
    fn partial_cmp<'_0, '_1> = core::cmp::PartialOrd::partial_cmp<'_0_0, '_0_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialOrd::{vtable}<Rhs>
}

// Full name: core::cmp::PartialEq
#[lang_item("eq")]
pub trait PartialEq<Self, Rhs>
{
    fn eq<'_0, '_1> = core::cmp::PartialEq::eq<'_0_0, '_0_1, Self, Rhs>[Self]
    vtable: core::cmp::PartialEq::{vtable}<Rhs>
}

// Full name: core::cmp::Ord
#[lang_item("Ord")]
pub trait Ord<Self>
{
    parent_clause0 : [@TraitClause0]: Eq<Self>
    parent_clause1 : [@TraitClause1]: PartialOrd<Self, Self>
    fn cmp<'_0, '_1> = core::cmp::Ord::cmp<'_0_0, '_0_1, Self>[Self]
    non-dyn-compatible
}

// Full name: core::iter::adapters::zip::TrustedRandomAccessNoCoerce
pub trait TrustedRandomAccessNoCoerce<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    const MAY_HAVE_SIDE_EFFECT : bool
    non-dyn-compatible
}

// Full name: core::cmp::Eq
#[lang_item("Eq")]
pub trait Eq<Self>
{
    parent_clause0 : [@TraitClause0]: PartialEq<Self, Self>
    non-dyn-compatible
}

// Full name: core::ops::function::FnMut
#[lang_item("fn_mut")]
pub trait FnMut<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FnOnce<Self, Args>
    parent_clause2 : [@TraitClause2]: Sized<Args>
    parent_clause3 : [@TraitClause3]: Tuple<Args>
    fn call_mut<'_0> = call_mut<'_0_0, Self, Args>[Self]
    non-dyn-compatible
}

// Full name: core::ops::function::FnOnce
#[lang_item("fn_once")]
pub trait FnOnce<Self, Args>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<Args>
    parent_clause2 : [@TraitClause2]: Tuple<Args>
    parent_clause3 : [@TraitClause3]: Sized<Self::Output>
    type Output
    fn call_once = call_once<Self, Args>[Self]
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::FromIterator
#[lang_item("FromIterator")]
pub trait FromIterator<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn from_iter<T, [@TraitClause0]: Sized<T>, [@TraitClause1]: IntoIterator<T>, @TraitClause1_1::Item = A> = from_iter<Self, A, T>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::ops::try_trait::Try
#[lang_item("Try")]
pub trait Try<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: FromResidual<Self, Self::Residual>
    parent_clause2 : [@TraitClause2]: Sized<Self::Output>
    parent_clause3 : [@TraitClause3]: Sized<Self::Residual>
    type Output
    type Residual
    fn from_output = from_output<Self>[Self]
    fn branch = branch<Self>[Self]
    non-dyn-compatible
}

// Full name: core::ops::try_trait::Residual
pub trait Residual<Self, O>
where
    Self::parent_clause3::Output = O,
    Self::parent_clause3::Residual = Self,
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<O>
    parent_clause2 : [@TraitClause2]: Sized<Self::TryType>
    parent_clause3 : [@TraitClause3]: Try<Self::TryType>
    type TryType
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::Extend
pub trait Extend<Self, A>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn extend<'_0, T, [@TraitClause0]: Sized<T>, [@TraitClause1]: IntoIterator<T>, @TraitClause1_1::Item = A> = extend<'_0_0, Self, A, T>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::default::Default
#[lang_item("Default")]
pub trait Default<Self>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    fn default = default<Self>[Self]
    non-dyn-compatible
}

// Full name: core::iter::traits::double_ended::DoubleEndedIterator
#[lang_item("DoubleEndedIterator")]
pub trait DoubleEndedIterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Iterator<Self>
    fn next_back<'_0> = next_back<'_0_0, Self>[Self]
    non-dyn-compatible
}

// Full name: core::iter::traits::exact_size::ExactSizeIterator
pub trait ExactSizeIterator<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Iterator<Self>
    non-dyn-compatible
}

// Full name: core::marker::Copy
#[lang_item("copy")]
pub trait Copy<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Clone<Self>
    non-dyn-compatible
}

// Full name: core::iter::traits::accum::Sum
pub trait Sum<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn sum<I, [@TraitClause0]: Sized<I>, [@TraitClause1]: Iterator<I>, @TraitClause1_1::Item = A> = core::iter::traits::accum::Sum::sum<Self, A, I>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::iter::traits::accum::Product
pub trait Product<Self, A>
{
    parent_clause0 : [@TraitClause0]: Sized<Self>
    parent_clause1 : [@TraitClause1]: Sized<A>
    fn product<I, [@TraitClause0]: Sized<I>, [@TraitClause1]: Iterator<I>, @TraitClause1_1::Item = A> = core::iter::traits::accum::Product::product<Self, A, I>[Self, @TraitClause0_0, @TraitClause0_1]
    non-dyn-compatible
}

// Full name: core::marker::Tuple
#[lang_item("tuple_trait")]
pub trait Tuple<Self>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    vtable: core::marker::Tuple::{vtable}
}

// Full name: core::ops::try_trait::FromResidual
#[lang_item("FromResidual")]
pub trait FromResidual<Self, R>
{
    parent_clause0 : [@TraitClause0]: MetaSized<Self>
    parent_clause1 : [@TraitClause1]: Sized<R>
    fn from_residual = from_residual<Self, R>[Self]
    non-dyn-compatible
}

// Full name: alloc::string::{impl From<&'_0 (Str)> for String}
impl<'_0> From<&'_0 (Str)> for String {
    parent_clause0 = Sized<String>
    parent_clause1 = Sized<&'_ (Str)>
    fn from = {impl From<&'_0 (Str)> for String}::from<'_0>
    non-dyn-compatible
}

// Full name: core::iter::traits::collect::{impl IntoIterator for I}
impl<I> IntoIterator for I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,
{
    parent_clause0 = @TraitClause0::parent_clause0
    parent_clause1 = @TraitClause1::parent_clause1
    parent_clause2 = @TraitClause0
    parent_clause3 = @TraitClause1
    type Item = @TraitClause1::Item
    type IntoIter = I
    fn into_iter = {impl IntoIterator for I}::into_iter<I>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: core::iter::range::{impl Iterator for Range<A>[@TraitClause0]}
impl<A> Iterator for Range<A>[@TraitClause0]
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: Step<A>,
{
    parent_clause0 = MetaSized<Range<A>[@TraitClause0]>
    parent_clause1 = @TraitClause0
    type Item = A
    fn next<'_0> = {impl Iterator for Range<A>[@TraitClause0]}::next<'_0_0, A>[@TraitClause0, @TraitClause1]
    non-dyn-compatible
}

// Full name: core::iter::range::{impl Step for i32}
impl Step for i32 {
    parent_clause0 = Sized<i32>
    parent_clause1 = {impl Clone for i32}
    parent_clause2 = {impl PartialOrd<i32> for i32}
    fn steps_between<'_0, '_1> = {impl Step for i32}::steps_between<'_0_0, '_0_1>
    fn forward_checked = {impl Step for i32}::forward_checked
    fn backward_checked = {impl Step for i32}::backward_checked
    non-dyn-compatible
}

// Full name: alloc::string::String::{impl Drop for String}
impl Drop for String {
    parent_clause0 = MetaSized<String>
    fn drop<'_0> = {impl Drop for String}::drop<'_0_0>
    non-dyn-compatible
}

// Full name: alloc::string::{impl Clone for String}
impl Clone for String {
    parent_clause0 = Sized<String>
    fn clone<'_0> = {impl Clone for String}::clone<'_0_0>
    non-dyn-compatible
}

// Full name: core::clone::impls::{impl Clone for i32}
impl Clone for i32 {
    parent_clause0 = Sized<i32>
    fn clone<'_0> = {impl Clone for i32}::clone<'_0_0>
    non-dyn-compatible
}

// Full name: core::cmp::impls::{impl PartialOrd<i32> for i32}
impl PartialOrd<i32> for i32 {
    parent_clause0 = {impl PartialEq<i32> for i32}
    fn partial_cmp<'_0, '_1> = {impl PartialOrd<i32> for i32}::partial_cmp<'_0_0, '_0_1>
    vtable: {impl PartialOrd<i32> for i32}::{vtable}
}

// Full name: core::cmp::impls::{impl PartialEq<i32> for i32}
impl PartialEq<i32> for i32 {
    fn eq<'_0, '_1> = {impl PartialEq<i32> for i32}::eq<'_0_0, '_0_1>
    vtable: {impl PartialEq<i32> for i32}::{vtable}
}

// Full name: complex::fn_complex
pub fn fn_complex(@1: i32, @2: i32) -> i32
{
    let @0: i32; // return
    let a@1: i32; // arg #1
    let b@2: i32; // arg #2
    let s@3: String; // local
    let @4: (); // anonymous local
    let @5: Range<i32>[Sized<i32>]; // anonymous local
    let @6: Range<i32>[Sized<i32>]; // anonymous local
    let iter@7: Range<i32>[Sized<i32>]; // local
    let @8: (); // anonymous local
    let @9: (); // anonymous local
    let @10: Option<i32>[Sized<i32>]; // anonymous local
    let @11: &'_ mut (Range<i32>[Sized<i32>]); // anonymous local
    let @12: &'_ mut (Range<i32>[Sized<i32>]); // anonymous local
    let @13: isize; // anonymous local
    let @14: !; // anonymous local
    let _i@15: i32; // local
    let @16: i32; // anonymous local
    let @17: i32; // anonymous local
    let @18: i32; // anonymous local
    let @19: i32; // anonymous local
    let @20: i32; // anonymous local
    let @21: bool; // anonymous local
    let @22: bool; // anonymous local
    let @23: bool; // anonymous local
    let @24: bool; // anonymous local
    let @25: i32; // anonymous local
    let @26: i32; // anonymous local
    let @27: i32; // anonymous local
    let @28: i32; // anonymous local
    let @29: i32; // anonymous local
    let @30: i32; // anonymous local
    let @31: (); // anonymous local
    let @32: String; // anonymous local
    let @33: &'_ (String); // anonymous local
    let @34: i32; // anonymous local
    let @35: bool; // anonymous local
    let @36: i32; // anonymous local
    let @37: !; // anonymous local
    let @38: i32; // anonymous local
    let @39: bool; // anonymous local
    let @40: i32; // anonymous local
    let @41: !; // anonymous local
    let @42: i32; // anonymous local
    let @43: i32; // anonymous local
    let @44: i32; // anonymous local
    let @45: (); // anonymous local
    let @46: (); // anonymous local
    let @47: (); // anonymous local
    let @48: (); // anonymous local
    let @49: (); // anonymous local
    let @50: (); // anonymous local
    let @51: (); // anonymous local

    bb0: {
        storage_live(s@3);
        s@3 := {impl From<&'_0 (Str)> for String}::from<'_>(const ("Start")) -> bb1 (unwind: bb2);
    }

    bb1: {
        storage_live(@4);
        storage_live(@5);
        storage_live(@6);
        @6 := Range { start: const (0 : i32), end: const (3 : i32) };
        @5 := {impl IntoIterator for I}::into_iter<Range<i32>[Sized<i32>]>[Sized<Range<i32>[Sized<i32>]>, {impl Iterator for Range<A>[@TraitClause0]}<i32>[Sized<i32>, {impl Step for i32}]](move (@6)) -> bb3 (unwind: bb4);
    }

    bb2: {
        unwind_continue;
    }

    bb3: {
        storage_dead(@6);
        storage_live(iter@7);
        iter@7 := move (@5);
        goto bb5;
    }

    bb4: {
        drop[{impl Drop for String}] s@3;
        goto bb2;
    }

    bb5: {
        storage_live(@9);
        storage_live(@10);
        storage_live(@11);
        storage_live(@12);
        @12 := &mut iter@7;
        @11 := &two-phase-mut *(@12);
        @10 := {impl Iterator for Range<A>[@TraitClause0]}::next<'_, i32>[Sized<i32>, {impl Step for i32}](move (@11)) -> bb6 (unwind: bb4);
    }

    bb6: {
        storage_dead(@11);
        @13 := @discriminant(@10);
        switch move (@13) -> 0 : isize: bb7, 1 : isize: bb8, otherwise: bb9;
    }

    bb7: {
        nop;
        nop;
        goto bb10;
    }

    bb8: {
        storage_live(_i@15);
        _i@15 := copy ((@10 as variant Option::Some).0);
        storage_live(@16);
        storage_live(@17);
        storage_live(@18);
        @18 := copy (a@1);
        storage_live(@19);
        @19 := copy (b@2);
        @20 := copy (@18) panic.+ copy (@19);
        nop;
        @17 := move (@20);
        storage_dead(@19);
        storage_dead(@18);
        nop;
        nop;
        nop;
        nop;
        nop;
        nop;
        @16 := move (@17) panic.% const (4 : i32);
        storage_dead(@17);
        switch copy (@16) -> 0 : i32: bb11, 1 : i32: bb12, 2 : i32: bb13, otherwise: bb14;
    }

    bb9: {
        undefined_behavior;
    }

    bb10: {
        storage_dead(@12);
        storage_dead(@10);
        storage_dead(@9);
        storage_dead(iter@7);
        storage_dead(@5);
        storage_dead(@4);
        storage_live(@42);
        @42 := copy (a@1);
        storage_live(@43);
        @43 := copy (b@2);
        @44 := copy (@42) panic.+ copy (@43);
        nop;
        @0 := move (@44);
        storage_dead(@43);
        storage_dead(@42);
        drop[{impl Drop for String}] s@3;
        storage_dead(s@3);
        return;
    }

    bb11: {
        storage_live(@25);
        storage_live(@26);
        @26 := copy (a@1);
        @25 := helper(move (@26)) -> bb15 (unwind: bb4);
    }

    bb12: {
        storage_live(@28);
        storage_live(@29);
        @29 := copy (b@2);
        @28 := helper(move (@29)) -> bb16 (unwind: bb4);
    }

    bb13: {
        @34 := copy (a@1) panic.- const (1 : i32);
        nop;
        a@1 := move (@34);
        storage_live(@35);
        storage_live(@36);
        @36 := copy (a@1);
        @35 := move (@36) < const (0 : i32);
        if move (@35) -> bb19 else -> bb20;
    }

    bb14: {
        @38 := copy (b@2) panic.- const (1 : i32);
        nop;
        b@2 := move (@38);
        storage_live(@39);
        storage_live(@40);
        @40 := copy (b@2);
        @39 := move (@40) < const (0 : i32);
        if move (@39) -> bb17 else -> bb18;
    }

    bb15: {
        storage_dead(@26);
        @27 := copy (a@1) panic.+ copy (@25);
        nop;
        a@1 := move (@27);
        storage_dead(@25);
        nop;
        nop;
        goto bb21;
    }

    bb16: {
        storage_dead(@29);
        @30 := copy (b@2) panic.+ copy (@28);
        nop;
        b@2 := move (@30);
        storage_dead(@28);
        storage_live(@31);
        storage_live(@32);
        storage_live(@33);
        @33 := &s@3;
        @32 := {impl Clone for String}::clone<'_>(move (@33)) -> bb22 (unwind: bb4);
    }

    bb17: {
        storage_dead(@40);
        storage_dead(@39);
        storage_dead(@16);
        storage_dead(_i@15);
        storage_dead(@12);
        storage_dead(@10);
        storage_dead(@9);
        goto bb5;
    }

    bb18: {
        storage_dead(@40);
        nop;
        nop;
        storage_dead(@39);
        goto bb21;
    }

    bb19: {
        storage_dead(@36);
        nop;
        nop;
        storage_dead(@35);
        storage_dead(@16);
        storage_dead(_i@15);
        goto bb10;
    }

    bb20: {
        storage_dead(@36);
        nop;
        nop;
        storage_dead(@35);
        goto bb21;
    }

    bb21: {
        storage_dead(@16);
        storage_dead(_i@15);
        storage_dead(@12);
        storage_dead(@10);
        storage_dead(@9);
        nop;
        nop;
        goto bb5;
    }

    bb22: {
        storage_dead(@33);
        @31 := core::mem::drop<String>[Sized<String>](move (@32)) -> bb23 (unwind: bb24);
    }

    bb23: {
        storage_dead(@32);
        storage_dead(@31);
        nop;
        nop;
        goto bb21;
    }

    bb24: {
        drop[{impl Drop for String}] @32;
        goto bb4;
    }
}

// Full name: complex::helper
fn helper(@1: i32) -> i32
{
    let @0: i32; // return
    let x@1: i32; // arg #1
    let @2: i32; // anonymous local
    let @3: i32; // anonymous local

    bb0: {
        storage_live(@2);
        @2 := copy (x@1);
        @3 := copy (@2) panic.* const (2 : i32);
        nop;
        @0 := move (@3);
        storage_dead(@2);
        return;
    }
}

// Full name: complex::main
fn main()
{
    let @0: (); // return
    let x@1: i32; // local
    let y@2: i32; // local
    let @3: i32; // anonymous local
    let @4: i32; // anonymous local
    let @5: i32; // anonymous local
    let @6: (); // anonymous local

    bb0: {
        storage_live(x@1);
        x@1 := const (0 : i32);
        storage_live(y@2);
        y@2 := const (1 : i32);
        storage_live(@3);
        storage_live(@4);
        @4 := copy (x@1);
        storage_live(@5);
        @5 := copy (y@2);
        @3 := fn_complex(move (@4), move (@5)) -> bb1 (unwind: bb2);
    }

    bb1: {
        storage_dead(@5);
        storage_dead(@4);
        storage_dead(@3);
        nop;
        @0 := ();
        storage_dead(y@2);
        storage_dead(x@1);
        @0 := ();
        return;
    }

    bb2: {
        unwind_continue;
    }
}

#[lang_item("from_fn")]
pub fn core::convert::From::from<Self, T>(@1: T) -> Self
where
    [@TraitClause0]: From<Self, T>,

#[lang_item("into_iter")]
pub fn core::iter::traits::collect::IntoIterator::into_iter<Self>(@1: Self) -> @TraitClause0::IntoIter
where
    [@TraitClause0]: IntoIterator<Self>,

#[lang_item("next")]
pub fn core::iter::traits::iterator::Iterator::next<'_0, Self>(@1: &'_0 mut (Self)) -> Option<@TraitClause0::Item>[@TraitClause0::parent_clause1]
where
    [@TraitClause0]: Iterator<Self>,

#[lang_item("clone_fn")]
pub fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 (Self)) -> Self
where
    [@TraitClause0]: Clone<Self>,

#[lang_item("mem_drop")]
pub fn core::mem::drop<T>(@1: T)
where
    [@TraitClause0]: Sized<T>,

pub fn core::ops::drop::Drop::drop<'_0, Self>(@1: &'_0 mut (Self))
where
    [@TraitClause0]: Drop<Self>,

pub fn core::iter::range::Step::steps_between<'_0, '_1, Self>(@1: &'_0 (Self), @2: &'_1 (Self)) -> (usize, Option<usize>[Sized<usize>])
where
    [@TraitClause0]: Step<Self>,

pub fn core::iter::range::Step::forward_checked<Self>(@1: Self, @2: usize) -> Option<Self>[@TraitClause0::parent_clause0]
where
    [@TraitClause0]: Step<Self>,

pub fn core::iter::range::Step::backward_checked<Self>(@1: Self, @2: usize) -> Option<Self>[@TraitClause0::parent_clause0]
where
    [@TraitClause0]: Step<Self>,

#[lang_item("cmp_partialord_cmp")]
pub fn core::cmp::PartialOrd::partial_cmp<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> Option<Ordering>[Sized<Ordering>]
where
    [@TraitClause0]: PartialOrd<Self, Rhs>,

#[lang_item("cmp_partialeq_eq")]
pub fn core::cmp::PartialEq::eq<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> bool
where
    [@TraitClause0]: PartialEq<Self, Rhs>,

// Full name: core::iter::range::{impl Iterator for Range<A>[@TraitClause0]}::next
pub fn {impl Iterator for Range<A>[@TraitClause0]}::next<'_0, A>(@1: &'_0 mut (Range<A>[@TraitClause0])) -> Option<A>[@TraitClause0]
where
    [@TraitClause0]: Sized<A>,
    [@TraitClause1]: Step<A>,

#[lang_item("ord_cmp_method")]
pub fn core::cmp::Ord::cmp<'_0, '_1, Self>(@1: &'_0 (Self), @2: &'_1 (Self)) -> Ordering
where
    [@TraitClause0]: Ord<Self>,

// Full name: core::iter::traits::collect::{impl IntoIterator for I}::into_iter
pub fn {impl IntoIterator for I}::into_iter<I>(@1: I) -> I
where
    [@TraitClause0]: Sized<I>,
    [@TraitClause1]: Iterator<I>,

// Full name: core::default::Default::default
#[lang_item("default_fn")]
pub fn default<Self>() -> Self
where
    [@TraitClause0]: Default<Self>,

// Full name: core::ops::function::FnMut::call_mut
pub fn call_mut<'_0, Self, Args>(@1: &'_0 mut (Self), @2: Args) -> @TraitClause0::parent_clause1::Output
where
    [@TraitClause0]: FnMut<Self, Args>,

// Full name: core::ops::function::FnOnce::call_once
pub fn call_once<Self, Args>(@1: Self, @2: Args) -> @TraitClause0::Output
where
    [@TraitClause0]: FnOnce<Self, Args>,

// Full name: core::ops::try_trait::Try::from_output
#[lang_item("from_output")]
pub fn from_output<Self>(@1: @TraitClause0::Output) -> Self
where
    [@TraitClause0]: Try<Self>,

// Full name: core::ops::try_trait::Try::branch
#[lang_item("branch")]
pub fn branch<Self>(@1: Self) -> ControlFlow<@TraitClause0::Residual, @TraitClause0::Output>[@TraitClause0::parent_clause1::parent_clause1, @TraitClause0::parent_clause2]
where
    [@TraitClause0]: Try<Self>,

// Full name: core::ops::try_trait::FromResidual::from_residual
#[lang_item("from_residual")]
pub fn from_residual<Self, R>(@1: R) -> Self
where
    [@TraitClause0]: FromResidual<Self, R>,

// Full name: core::iter::traits::collect::FromIterator::from_iter
#[lang_item("from_iter_fn")]
pub fn from_iter<Self, A, T>(@1: T) -> Self
where
    [@TraitClause0]: FromIterator<Self, A>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: IntoIterator<T>,
    @TraitClause2::Item = A,

// Full name: core::iter::traits::collect::Extend::extend
pub fn extend<'_0, Self, A, T>(@1: &'_0 mut (Self), @2: T)
where
    [@TraitClause0]: Extend<Self, A>,
    [@TraitClause1]: Sized<T>,
    [@TraitClause2]: IntoIterator<T>,
    @TraitClause2::Item = A,

// Full name: core::iter::traits::double_ended::DoubleEndedIterator::next_back
pub fn next_back<'_0, Self>(@1: &'_0 mut (Self)) -> Option<@TraitClause0::parent_clause1::Item>[@TraitClause0::parent_clause1::parent_clause1]
where
    [@TraitClause0]: DoubleEndedIterator<Self>,

// Full name: core::iter::range::{impl Step for i32}::steps_between
pub fn {impl Step for i32}::steps_between<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> (usize, Option<usize>[Sized<usize>])

// Full name: core::iter::range::{impl Step for i32}::forward_checked
pub fn {impl Step for i32}::forward_checked(@1: i32, @2: usize) -> Option<i32>[Sized<i32>]

// Full name: core::iter::range::{impl Step for i32}::backward_checked
pub fn {impl Step for i32}::backward_checked(@1: i32, @2: usize) -> Option<i32>[Sized<i32>]

// Full name: core::clone::impls::{impl Clone for i32}::clone
pub fn {impl Clone for i32}::clone<'_0>(@1: &'_0 (i32)) -> i32

// Full name: core::cmp::impls::{impl PartialOrd<i32> for i32}::partial_cmp
pub fn {impl PartialOrd<i32> for i32}::partial_cmp<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> Option<Ordering>[Sized<Ordering>]

// Full name: core::cmp::impls::{impl PartialEq<i32> for i32}::eq
pub fn {impl PartialEq<i32> for i32}::eq<'_0, '_1>(@1: &'_0 (i32), @2: &'_1 (i32)) -> bool

pub fn core::iter::traits::accum::Sum::sum<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: Sum<Self, A>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Iterator<I>,
    @TraitClause2::Item = A,

pub fn core::iter::traits::accum::Product::product<Self, A, I>(@1: I) -> Self
where
    [@TraitClause0]: Product<Self, A>,
    [@TraitClause1]: Sized<I>,
    [@TraitClause2]: Iterator<I>,
    @TraitClause2::Item = A,

// Full name: alloc::string::{impl Clone for String}::clone
pub fn {impl Clone for String}::clone<'_0>(@1: &'_0 (String)) -> String

// Full name: alloc::string::{impl From<&'_0 (Str)> for String}::from
pub fn {impl From<&'_0 (Str)> for String}::from<'_0>(@1: &'_0 (Str)) -> String

// Full name: alloc::string::String::{impl Drop for String}::drop
fn {impl Drop for String}::drop<'_0>(@1: &'_0 mut (String))
